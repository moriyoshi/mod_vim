/* 
**  mod_vim.c -- Apache sample vim module
**  [Autogenerated via ``apxs -n vim -g'']
**
**  To play with this sample module first compile it into a
**  DSO file and install it into Apache's modules directory 
**  by running:
**
**    $ apxs -c -i mod_vim.c
**
**  Then activate it in Apache's httpd.conf file for instance
**  for the URL /vim in as follows:
**
**    #   httpd.conf
**    LoadModule vim_module modules/mod_vim.so
**    <Location /vim>
**    SetHandler vim
**    </Location>
**
**  Then after restarting Apache via
**
**    $ apachectl restart
**
**  you immediately can request the URL /vim and watch for the
**  output of this module. This can be achieved for instance via:
**
**    $ lynx -mime_header http://localhost/vim 
**
**  The output should be similar to the following one:
**
**    HTTP/1.1 200 OK
**    Date: Tue, 31 Mar 1998 14:42:22 GMT
**    Server: Apache/1.3.4 (Unix)
**    Connection: close
**    Content-Type: text/html
**  
**    The sample page from mod_vim.c
*/ 

#include <stdlib.h>
#include "httpd.h"
#include "http_config.h"
#include "http_protocol.h"
#include "http_log.h"
#include "ap_config.h"
#include "conv.h"
#include "remote.h"
#include "apr_json.h"

typedef struct mod_vim_server_config {
    const char *vim_version;
    const char *encoding;
    const char *server_name;
    const char *expr;
#ifdef USE_X11
    const char *display; 
#endif
} mod_vim_server_config;

typedef struct mod_vim_dir_config {
    const char *server_name;
    const char *expr;
} mod_vim_dir_config;

static void mod_vim_register_hooks(apr_pool_t *p);
static const char *mod_vim_set_string_slot(cmd_parms *cmd, void *dummy, const char *arg);
static const char *mod_vim_set_server_name(cmd_parms *cmd, void *dummy, const char *arg);
static const char *mod_vim_set_expr(cmd_parms *cmd, void *dummy, const char *arg);

/* global thingies */
#ifdef USE_X11
static Display *dpy;
#endif
static VimRemotingClient *client;

static void *mod_vim_create_dir_config(apr_pool_t *p, char *dir)
{
    mod_vim_dir_config *config = apr_pcalloc(p, sizeof(*config));
    config->server_name = NULL;
    config->expr = NULL;
    return config;
}

static void *mod_vim_merge_dir_config(apr_pool_t *p, void *base, void *overrides)
{
    mod_vim_dir_config *base_config = base,
                       *overriding_config = overrides,
                       *new_config = apr_pcalloc(p, sizeof(*new_config));

    new_config->server_name = overriding_config->server_name ?
            overriding_config->server_name: base_config->server_name;
    new_config->expr = overriding_config->expr ?
            overriding_config->expr: base_config->expr;

    return new_config;
}

static void *mod_vim_create_server_config(apr_pool_t *p, server_rec *s)
{
    mod_vim_server_config *config = apr_pcalloc(p, sizeof(*config));
    config->vim_version = "7.2";
    config->encoding = "UTF-8";
    config->server_name = "VIM";
    config->expr = "\"[200,{\\\"Content-Type\\\":\\\"text/html;charset=us-ascii\\\"},[\\\"<html><body><h1>It works!</h1></body></html>\\\"]]\"";
    config->display = getenv("DISPLAY");
    return config;
}

static const command_rec mod_vim_cmds[] = {
#ifdef USE_X11
    AP_INIT_TAKE1(
        "VimDisplay",                       /* directive name */
        mod_vim_set_string_slot,            /* config action routine */
        (void *)APR_OFFSETOF(mod_vim_server_config, display), /* argument to include in call */
        RSRC_CONF,                          /* where available */
        "Specifies a X Display number"  /* directive description */
    ),
#endif
    AP_INIT_TAKE1(
        "VimVersion",
        mod_vim_set_string_slot,
        (void *)APR_OFFSETOF(mod_vim_server_config, vim_version),
        RSRC_CONF,
        "Specifies the Vim version that the server must comply"
    ),
    AP_INIT_TAKE1(
        "VimEncoding",
        mod_vim_set_string_slot,
        (void *)APR_OFFSETOF(mod_vim_server_config, encoding),
        RSRC_CONF,
        "Specifies the Vim version that the server must comply"
    ),
    AP_INIT_TAKE1(
        "VimServerName",
        mod_vim_set_server_name,
        NULL,
        RSRC_CONF|ACCESS_CONF,
    ),
    AP_INIT_RAW_ARGS(
        "VimExpr",
        mod_vim_set_expr,
        NULL,
        RSRC_CONF|ACCESS_CONF,
    ),
    {NULL}
};

/* Dispatch list for API hooks */
module AP_MODULE_DECLARE_DATA vim_module = {
    STANDARD20_MODULE_STUFF, 
    mod_vim_create_dir_config,    /* create per-dir    config structures */
    mod_vim_merge_dir_config,     /* merge  per-dir    config structures */
    mod_vim_create_server_config, /* create per-server config structures */
    NULL,                         /* merge  per-server config structures */
    mod_vim_cmds,                 /* table of config file commands       */
    mod_vim_register_hooks        /* register hooks                      */
};

static const char *mod_vim_set_string_slot(cmd_parms *cmd, void *dummy, const char *arg)
{
    mod_vim_server_config *config = ap_get_module_config(cmd->server->module_config, &vim_module);
    *(const char **)((char *)config + (long)cmd->info) = arg;
    return NULL;
}

static const char *mod_vim_set_server_name(cmd_parms *cmd, void *dconf, const char *arg)
{
    if (dconf) {
        mod_vim_dir_config *config = dconf;
        config->server_name = arg;
    } else {
        mod_vim_server_config *config = ap_get_module_config(cmd->server->module_config, &vim_module);
        config->server_name = arg;
    }
    return NULL;
}

static const char *mod_vim_set_expr(cmd_parms *cmd, void *dconf, const char *arg)
{
    if (dconf) {
        mod_vim_dir_config *config = dconf;
        config->expr = arg;
    } else {
        mod_vim_server_config *config = ap_get_module_config(cmd->server->module_config, &vim_module);
        config->expr = arg;
    }
    return NULL;
}

static void mod_vim_append_immortal_bucket(apr_bucket_brigade *brigade, const char *str, apr_size_t str_len)
{
    APR_BRIGADE_INSERT_TAIL(brigade, apr_bucket_immortal_create(str, str_len, brigade->bucket_alloc));
}

static void mod_vim_append_transient_bucket(apr_bucket_brigade *brigade, const char *str, apr_size_t str_len)
{
    APR_BRIGADE_INSERT_TAIL(brigade, apr_bucket_transient_create(str, str_len, brigade->bucket_alloc));
}

static void mod_vim_append_escaped_string_literal(apr_bucket_brigade *brigade, const char *str, apr_size_t str_len)
{
    /*
     * \... three-digit octal number (e.g., "\316")
     * \..  two-digit octal number (must be followed by non-digit)
     * \.   one-digit octal number (must be followed by non-digit)
     * \x.. byte specified with two hex numbers (e.g., "\x1f")
     * \x.  byte specified with one hex number (must be followed by non-hex char)
     * \X.. same as \x..
     * \X.  same as \x.
     * \u....   character specified with up to 4 hex numbers, stored according to the
     *  current value of 'encoding' (e.g., "\u02a4")
     *  \U....  same as \u....
     *  \b  backspace <BS>
     *  \e  escape <Esc>
     *  \f  formfeed <FF>
     *  \n  newline <NL>
     *  \r  return <CR>
     *  \t  tab <Tab>
     *  \\  backslash
     *  \"  double quote
     */
    const char *chunk = str;
    const char *p = str, *e = str + str_len;
    while (p < e) {
        unsigned char c = *(unsigned char *)p;
        switch (c) {
        case '\b':
            mod_vim_append_transient_bucket(brigade, chunk, p - chunk);
            mod_vim_append_immortal_bucket(brigade, "\\\b", 2);
            chunk = p + 1;
            break;
        case '\x1b':
            mod_vim_append_transient_bucket(brigade, chunk, p - chunk);
            mod_vim_append_immortal_bucket(brigade, "\\\e", 2);
            chunk = p + 1;
            break;
        case '\f':
            mod_vim_append_transient_bucket(brigade, chunk, p - chunk);
            mod_vim_append_immortal_bucket(brigade, "\\\f", 2);
            chunk = p + 1;
            break;
        case '\n':
            mod_vim_append_transient_bucket(brigade, chunk, p - chunk);
            mod_vim_append_immortal_bucket(brigade, "\\\n", 2);
            chunk = p + 1;
            break;
        case '\r':
            mod_vim_append_transient_bucket(brigade, chunk, p - chunk);
            mod_vim_append_immortal_bucket(brigade, "\\\r", 2);
            chunk = p + 1;
            break;
        case '\t':
            mod_vim_append_transient_bucket(brigade, chunk, p - chunk);
            mod_vim_append_immortal_bucket(brigade, "\\\t", 2);
            chunk = p + 1;
            break;
        case '\\':
            mod_vim_append_transient_bucket(brigade, chunk, p - chunk);
            mod_vim_append_immortal_bucket(brigade, "\\\\", 2);
            chunk = p + 1;
            break;
        case '"':
            mod_vim_append_transient_bucket(brigade, chunk, p - chunk);
            mod_vim_append_immortal_bucket(brigade, "\\\"", 2);
            chunk = p + 1;
            break;
        default:
            if (!isprint(c)) {
                char buf[2] = {
                    "0123456789abcdef"[c >> 4],
                    "0123456789abcdef"[c & 15]
                };
                mod_vim_append_transient_bucket(brigade, chunk, p - chunk);
                mod_vim_append_immortal_bucket(brigade, "\\x", 2);
                APR_BRIGADE_INSERT_TAIL(brigade, apr_bucket_heap_create(buf, 2, NULL, brigade->bucket_alloc));
                chunk = p + 1;
            }
            break;
        }
        p++;
    }
    if (chunk < p)
        mod_vim_append_transient_bucket(brigade, chunk, p - chunk);
}

static int mod_vim_build_request_json_add_header_cb(void *data, const char *key, const char *value)
{
    apr_hash_t *h = data;
    apr_hash_set(h, key, strlen(key), value);
    return 1;
}

static apr_status_t mod_vim_read_request_body(char **body, apr_size_t *body_len, request_rec *r, apr_pool_t *pool)
{
    apr_status_t status;
    apr_bucket_brigade *brigade = apr_brigade_create(pool, r->connection->bucket_alloc);
    if ((status = ap_get_brigade(
            r->input_filters, brigade, AP_MODE_READBYTES,
            APR_BLOCK_READ, HUGE_STRING_LEN))) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
                      "Error reading request entity data");
        return status;
    }

    return apr_brigade_pflatten(brigade, body, body_len, pool);
}

static apr_status_t mod_vim_build_request_json(char **json, apr_size_t *json_len, request_rec *r, apr_pool_t *pool)
{
    apr_status_t status = OK;
    apr_pool_t *subpool = NULL;
    apr_bucket_alloc_t *bucket_alloc = NULL;
    apr_bucket_brigade *json_bb = NULL;
    apr_json_value_t request_json = { APR_JSON_OBJECT };
    apr_json_value_t uri = { APR_JSON_STRING };
    apr_json_value_t method = { APR_JSON_STRING };
    apr_json_value_t filename = { APR_JSON_STRING };
    apr_json_value_t path_info = { APR_JSON_NULL };
    apr_json_value_t headers = { APR_JSON_OBJECT };
    apr_json_value_t request_body = { APR_JSON_STRING };

    if ((status = apr_pool_create(&subpool, pool))) {
        return status;
    }

    if ((status = mod_vim_read_request_body((char **)&request_body.value.string.p, &request_body.value.string.len, r, subpool))) {
        goto out;
    }

    bucket_alloc = apr_bucket_alloc_create(subpool);

    json_bb = apr_brigade_create(subpool, bucket_alloc);

    request_json.value.object = apr_hash_make(subpool);

    apr_hash_set(request_json.value.object, "content", sizeof("content") - 1, &request_body);

    uri.value.string.p = r->uri;
    uri.value.string.len = strlen(uri.value.string.p);
    apr_hash_set(request_json.value.object, "uri", sizeof("uri") - 1, &uri);

    filename.value.string.p = r->filename;
    filename.value.string.len = strlen(filename.value.string.p);
    apr_hash_set(request_json.value.object, "filename", sizeof("filename") - 1, &filename);

    if (r->path_info) {
        path_info.type = APR_JSON_STRING;
        path_info.value.string.p = r->path_info;
        path_info.value.string.len = strlen(path_info.value.string.p);
    }
    apr_hash_set(request_json.value.object, "path_info", sizeof("path_info") - 1, &path_info);

    method.value.string.p = r->method;
    method.value.string.len = strlen(r->method);
    apr_hash_set(request_json.value.object, "method", sizeof("method") - 1, &method);

    headers.value.object = apr_hash_make(subpool);
    apr_table_do(mod_vim_build_request_json_add_header_cb, headers.value.object, r->headers_in, NULL);

    apr_json_encode(json_bb, &request_json, subpool);

    APR_BRIGADE_INSERT_TAIL(json_bb, apr_bucket_eos_create(bucket_alloc));

    status = apr_brigade_pflatten(json_bb, json, json_len, pool);

out:
    if (json_bb)
        apr_brigade_destroy(json_bb);
    if (bucket_alloc)
        apr_bucket_alloc_destroy(bucket_alloc);
    if (subpool)
        apr_pool_destroy(subpool);
    return status;
}

/* The sample content handler */
static int mod_vim_handler(request_rec *r)
{
    apr_status_t status;
    char *result = NULL;
    apr_json_value_t *value;
    const mod_vim_dir_config *dconfig;
    const mod_vim_server_config *sconfig;
    const char *server_name;
    const char *orig_expr;

    if (strcmp(r->handler, "vim"))
        return DECLINED;

    dconfig = ap_get_module_config(r->per_dir_config, &vim_module);
    sconfig = ap_get_module_config(r->server->module_config, &vim_module);
    server_name = dconfig->server_name ? dconfig->server_name: sconfig->server_name;
    orig_expr = dconfig->expr ? dconfig->expr: sconfig->expr;

    if (!server_name) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "VimServerName is not set");
        return HTTP_INTERNAL_SERVER_ERROR;
    }

    if (!orig_expr) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "VimExpr is not given");
        return HTTP_INTERNAL_SERVER_ERROR;
    }

    {
        int retval = OK;
        apr_bucket_alloc_t *bucket_alloc = apr_bucket_alloc_create(r->pool);
        apr_bucket_brigade *expr_bb = apr_brigade_create(r->pool, bucket_alloc);
        {
            const char *p = orig_expr, *chunk = orig_expr;

            while (*chunk) {
                p = strstr(chunk, "@@");
                if (p) {
                    apr_pool_t *subpool;
                    char *json;
                    apr_size_t json_len;

                    if ((status = apr_pool_create(&subpool, NULL))) {
                        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, "Failed to allocate memory pool");
                        retval = HTTP_INTERNAL_SERVER_ERROR;
                        goto out_send_server;
                    }

                    mod_vim_build_request_json(&json, &json_len, r, subpool);

                    mod_vim_append_transient_bucket(expr_bb, chunk, p - chunk);
                    mod_vim_append_immortal_bucket(expr_bb, "\"", 1);
                    mod_vim_append_escaped_string_literal(expr_bb, json, json_len);
                    mod_vim_append_immortal_bucket(expr_bb, "\"", 1);

                    apr_pool_destroy(subpool);
                    chunk = p + 2;
                } else {
                    p = chunk + strlen(chunk);
                    mod_vim_append_transient_bucket(expr_bb, chunk, p - chunk);
                    chunk = p;
                }
            }
        }

        APR_BRIGADE_INSERT_TAIL(expr_bb, apr_bucket_eos_create(bucket_alloc));

        {
            char *expr;
            apr_size_t expr_len;

            if ((status = apr_brigade_pflatten(expr_bb, &expr, &expr_len, r->pool))) {
                ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, "Error occurred during building expression");
                retval = HTTP_INTERNAL_SERVER_ERROR;
                goto out_send_server;
            }

            if (serverSendToVim(client, server_name, expr, expr_len, &result)) {
                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Failed to communicate with the server");
                retval = HTTP_INTERNAL_SERVER_ERROR;
                goto out_send_server;
            }
        }

    out_send_server:
        apr_brigade_destroy(expr_bb);
        apr_bucket_alloc_destroy(bucket_alloc);
        if (retval != OK)
            return retval;
    }

    if (apr_json_decode(&value, result, strlen(result), r->pool) || value->type != APR_JSON_ARRAY || value->value.array->nelts != 3) {
        free(result);
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Invalid JSON response from the Vim server: the response must be a three-element array -- %s", result);
        return HTTP_INTERNAL_SERVER_ERROR;
    }

    free(result);

    if (((apr_json_value_t **)value->value.array->elts)[0]->type != APR_JSON_LONG) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Invalid JSON response from the Vim server: first element must be an integer that represents HTTP status");
        return HTTP_INTERNAL_SERVER_ERROR;
    }

    if (((apr_json_value_t **)value->value.array->elts)[1]->type != APR_JSON_OBJECT) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Invalid JSON response from the Vim server: second element must be an object that contains response headers");
        return HTTP_INTERNAL_SERVER_ERROR;
    }

    if (((apr_json_value_t **)value->value.array->elts)[2]->type != APR_JSON_ARRAY) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Invalid JSON response from the Vim server: third element must be an array that contains repsponse body");
        return HTTP_INTERNAL_SERVER_ERROR;
    }

    r->status = ((apr_json_value_t **)value->value.array->elts)[0]->value.lnumber;

    {
        apr_hash_t *headers = ((apr_json_value_t **)value->value.array->elts)[1]->value.object;
        apr_hash_index_t *i;
        for (i = apr_hash_first(r->pool, headers); i; i = apr_hash_next(i)) {
            const char *key;
            apr_ssize_t key_len;
            apr_json_value_t *value;
            apr_hash_this(i, (const void **)&key, &key_len, (void **)&value);

            if (value->type != APR_JSON_STRING) {
                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Invalid JSON response from the Vim server: header value must be a string");
                return HTTP_INTERNAL_SERVER_ERROR;
            }
            if (strcasecmp(key, "Content-Type") == 0)
                r->content_type = value->value.string.p;
            else
                apr_table_set(r->headers_out, key, value->value.string.p);
        }
    }

    if (r->header_only)
        return OK;

    {
        apr_json_value_t **p, **e;
        apr_array_header_t *chunks = ((apr_json_value_t **)value->value.array->elts)[2]->value.array;
        apr_bucket_brigade *brigade = apr_brigade_create(r->pool, r->connection->bucket_alloc);
        for (p = (apr_json_value_t **)chunks->elts, e = p + chunks->nelts; p < e; p++) {
            apr_json_value_t *chunk = *p;
            if (chunk->type != APR_JSON_STRING) {
                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Invalid JSON response from the Vim server: elements for response body must be strings");
                return HTTP_INTERNAL_SERVER_ERROR;
            }
            APR_BRIGADE_INSERT_TAIL(brigade, apr_bucket_transient_create(chunk->value.string.p, chunk->value.string.len, r->connection->bucket_alloc));
        }

        return ap_pass_brigade(r->output_filters, brigade);
    }
}

static int mod_vim_init(server_rec *s)
{
    mod_vim_server_config *config = ap_get_module_config(s->module_config, &vim_module);
    conv_init();
    return 0;
}

static apr_status_t mod_vim_cleanup(void *tmp)
{
    VimRemotingClient_delete(client);
    if (dpy)
        XCloseDisplay(dpy);
    conv_cleanup();
    return APR_SUCCESS;
}

static apr_status_t mod_vim_child_cleanup(void *tmp)
{
    conv_cleanup();
    return APR_SUCCESS;
}

static void mod_vim_child_init(apr_pool_t *pchild, server_rec *s)
{
    mod_vim_server_config *config = ap_get_module_config(s->module_config, &vim_module);
    conv_init();
#ifdef USE_X11
    XInitThreads();
    dpy = XOpenDisplay(config->display);
    if (!dpy) {
        conv_cleanup();
        return;
    }
    client = VimRemotingClient_new(s, config->vim_version, config->encoding, dpy);
#endif
    apr_pool_cleanup_register(pchild, NULL, mod_vim_cleanup, apr_pool_cleanup_null);
}

static int mod_vim_post_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp, server_rec *s)
{
    void *data;
    const char userdata_key[] = "MOD_VIM";

    /* make sure that the initialization only happens after all the modules
     * are loaded */
	apr_pool_userdata_get(&data, userdata_key, s->process->pool);
	if (!data) {
		apr_pool_userdata_set(mod_vim_post_config, userdata_key, apr_pool_cleanup_null, s->process->pool);
		return OK;
	}

    if (mod_vim_init(s)) {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, "Failed to initialize Vim module");
        return DECLINED;
    }
    apr_pool_cleanup_register(pconf, NULL, mod_vim_cleanup, apr_pool_cleanup_null);

    return OK;
}

static void mod_vim_register_hooks(apr_pool_t *p)
{
    ap_hook_handler(mod_vim_handler, NULL, NULL, APR_HOOK_MIDDLE);
    ap_hook_child_init(mod_vim_child_init, NULL, NULL, APR_HOOK_MIDDLE);
    ap_hook_post_config(mod_vim_post_config, NULL, NULL, APR_HOOK_MIDDLE);
}

